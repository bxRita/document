# 11. 模板方法模式

模板方法是一种只需要使用继承就可以实现的模式

模板方法模式由两部分组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 

## 11.3 抽象类
首先要说明的是，模板方法模式是一种严重依赖抽象类的设计模式。JavaScript 在语言层面并没有提供对抽象类的支持，我们也很难模拟抽象类的实现。这一节我们将着重讨论 Java 中抽象类的作用，以及 JavaScript 没有抽象类时所做出的让步和变通

### 11.3.1 抽象类的作用

在 Java 中，类分为两种，一种为具体类，另一种为抽象类。具体类可以被实例化，抽象类不能被实例化。要了解抽象类不能被实例化的原因，我们可以思考“饮料”这个抽象类。

想象这样一个场景：我们口渴了，去便利店想买一瓶饮料，我们不能直接跟店员说：“来一瓶饮料。”如果我们这样说了，那么店员接下来肯定会问：“要什么饮料？”饮料只是一个抽象名词，只有当我们真正明确了的饮料类型之后，才能得到一杯咖啡、茶、或者可乐。

由于抽象类不能被实例化，如果有人编写了一个抽象类，那么这个抽象类一定是用来被某些具体类继承的。

### 11.3.2 抽象方法和具体方法
抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，是一些“哑”方法。当子类继承了这个抽象类时，必须重写父类的抽象方法。

在 Java 中编译器会保证子类会重写父类中的抽象方法，但在 JavaScript 中却没有进行这些检查工作。我们在编写代码的时候得不到任何形式的警告，完全寄托于程序员的记忆力和自觉性是很危险的，特别是当我们使用模板方法模式这种完全依赖继承而实现的设计模式时。

下面提供两种变通的解决方案：
-  第 1 种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，这就要求我们在业务代码中添加一些跟业务逻辑无关的代码

- 第 2 种方案是让 Beverage.prototype.brew 等方法直接抛出一个异常，如果因为粗心忘记编写 Coffee.prototype.brew 方法，那么至少我们会在程序运行时得到一个错误：
    ```js
        Beverage.prototype.brew = function(){ 
            throw new Error( '子类必须重写 brew 方法' ); 
        }; 
        Beverage.prototype.pourInCup = function(){ 
            throw new Error( '子类必须重写 pourInCup 方法' ); 
        }; 
        Beverage.prototype.addCondiments = function(){ 
            throw new Error( '子类必须重写 addCondiments 方法' ); 
        }; 
    ```
第 2 种解决方案的优点是实现简单，付出的额外代价很少；缺点是我们得到错误信息的时间点太靠后（在程序运行过程中才知道哪里发生了错误）。

## 11.5 钩子方法
 通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用于大多数子类的，但如果有一些特别“个性”的子类呢？比如我们在饮料类 Beverage 中封装了饮料的冲泡顺序：

(1) 把水煮沸
(2) 用沸水冲泡饮料
(3) 把饮料倒进杯子
(4) 加调料

这 4 个冲泡饮料的步骤适用于咖啡和茶，在我们的饮料店里，根据这 4 个步骤制作出来的咖啡和茶，一直顺利地提供给绝大部分客人享用。但有一些客人喝咖啡是不加调料（糖和牛奶）的。既然 Beverage 作为父类，已经规定好了冲泡饮料的 4 个步骤，那么有什么办法可以让子类不受这个约束呢？

钩子方法（hook）可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。

在这个例子里，我们把挂钩的名字定为 customerWantsCondiments，接下来将挂钩放入 Beverage类，看看我们如何得到一杯不需要糖和牛奶的咖啡，代码如下：

```js
var Beverage = function(){}; 
Beverage.prototype.boilWater = function(){ 
    console.log( '把水煮沸' ); 
}; 
Beverage.prototype.brew = function(){ 
    throw new Error( '子类必须重写 brew 方法' ); 
}; 
Beverage.prototype.pourInCup = function(){ 
    throw new Error( '子类必须重写 pourInCup 方法' ); 
}; 
Beverage.prototype.addCondiments = function(){ 
    throw new Error( '子类必须重写 addCondiments 方法' ); 
}; 
Beverage.prototype.customerWantsCondiments = function(){ 
    return true; // 默认需要调料
}; 
Beverage.prototype.init = function(){ 
    this.boilWater(); 
    this.brew(); 
    this.pourInCup(); 
    if ( this.customerWantsCondiments() ){ // 如果挂钩返回 true，则需要调料
        this.addCondiments(); 
    } 
}; 
var CoffeeWithHook = function(){}; 
CoffeeWithHook.prototype = new Beverage(); 
CoffeeWithHook.prototype.brew = function(){ 
    console.log( '用沸水冲泡咖啡' ); 
}; 
CoffeeWithHook.prototype.pourInCup = function(){ 
    console.log( '把咖啡倒进杯子' ); 
}; 
CoffeeWithHook.prototype.addCondiments = function(){ 
 console.log( '加糖和牛奶' ); 
}; 
CoffeeWithHook.prototype.customerWantsCondiments = function(){ 
    return window.confirm( '请问需要调料吗？' ); 
}; 
var coffeeWithHook = new CoffeeWithHook(); 
coffeeWithHook.init();
```

## 11.6 好莱坞原则

学习完模板方法模式之后，我们要引入一个新的设计原则——著名的“好莱坞原则”。

好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。”

在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，高层组件对待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”。

模板方法模式是好莱坞原则的一个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法应该在什么时候被调用。作为子类，只负责提供一些设计上的细节。

除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布-订阅模式和回调函数。
- 发布订阅模式

- 回调函数

## 11.7 真的需要“继承”吗

模板方法模式是基于继承的一种设计模式，父类封装了子类的算法框架和方法的执行顺序，子类继承父类之后，父类通知子类执行这些方法，好莱坞原则很好地诠释了这种设计技巧，即高层组件调用底层组件

## 11.8

模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放-封闭原则的
