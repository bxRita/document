### 5.1 工作原理概括
#### 5.1.1 基本概念     
在了解webpack原理之前，需要掌握以下几个核心概念    
- Entry: 入口， Webpack 执行构建的第一步将从Entry开始，可抽象成输入。
- Module ： 模块，在Webpack 里一切皆模块， 一个模块对应一个文件。Webpack 会从配置的Entry 开始，递归找出所有依赖的模块。
- Chunk ： 代码块， 一个Chunk 由多个模块组合而成，用于代码合并与分割。
- Loader ： 模块转换器，用于将模块的原内容按照需求转换成新内容。
- Plugin ： 扩展插件，在Webpack 构建流程中的特定时机会广播对应的事件，插件可以监听这些事件的发生，在特定的时机做对应的事情。

#### 5.1.2 流程概括    
Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程。   
- 初始化参数： 从配置文件和Shell 语句中读取与合并参数，得出最终的参数。
- 开始编译：用上一步得到的参数初始化Compiler 对象，加载所有配置的插件，通过执行对象的run 方法开始执行编译。
- 确定入口： 根据配置中的entry 找出所有入口文件。编译模块：从入口文件出发，调用所有配置的Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
- 完成模块编译： 在经过第4 步使用Loader 翻译完所有模块后， 得到了每个模块被翻译后的最终内容及它们之间的依赖关系。
- 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk,再将每个Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会。
- 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中。

在以上过程中， Webpack 会在特定的时间点广播特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，井且插件可以调用Webpack 提供的API 改变Webpack 的运行结果。

#### 5.1.3 流程细节
- Webpack 的构建流程可以分为以下三大阶段。初始化：启动构建，读取与合并配置参数，加载Plugin ，实例化Compiler 。
- 编译：从Entry 发出，针对每个Module 串行调用对应的Loader 去翻译文件的内容，再找到该Module 依赖的Module ，递归地进行编译处理。
- 输出：将编译后的Module 组合成Chunk ，将Chunk 转换成文件，输出到文件系统中。


**1.初始化阶段**

初始阶段会发生的事件及解释     
| 事件名 | 解释 | 
| :------| :------ | 
| 初始化参数 | 从配置文件和Shell 语句中读取与合并参数，得出最终的参数．在这个过程中还会执行配置文件中的插件实例化语句new Plugin() | 
| 实例化Compiler | 用上一步得到的参数初始化Compiler 实例， Compiler 负责文件监听和启动编译。在Compiler实例中包含了完整的Webpack 配置，全局只有一个Compiler 实例 | 
| 加载插件 | 依次调用插件的apply 方法，让插件可以监听后续的所有事件节点．同时向插件传入compiler实例的引用，以方便插件通过compiler 调用Webpack 提供的API | 
| environment | 开始应用Node.js 风格的文件系统到compiler 对象，以方便后续的文件寻找和读取 | 
| entry-option | 读取配置的Entrys ，为每个Entry 实例化一个对应的EntryPlugin ，为后面该Entry 的递归解析工作做准备 | 
| after-plugins | 调用完所有内置的和配置的插件的apply 方法 | 
| after-resolvers | 根据配置初始化resolver, resolver 负责在文件系统中寻找指定路径的文件 | 

**2.编译阶段**

编译阶段会发生的事件及解释     
| 事件名 | 解释 | 
| :------| :------ | 
| run | 启动一次新的编译 | 
| watch-run | 和run 类似，区别在于它是在监听模式下启动编译，在这个事件中可以获取是哪些文件发生了变化从而导致重新启动一次新的编译 | 
| compile | 该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上compiler 对象 | 
| compilation | 当Webpack 以开发模式运行时，每当检测到文件的变化，便有一次新的Compilation 被创建。 一个Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。Compilation对象也提供了很多事件回调给插件进行扩展 | 
| make | 一个新的Compilation 创建完毕，即将从Entry 开始读取文件，根据文件的类型和配置的Loader对文件进行编译，编译完后再找出该文件依赖的文件，递归地编译和解析 | 
| after-compile | 一次Compilation 执行完成 | 
| invalid | 当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致Webpack 退出 | 

在编译阶段中，最重要的事件是compilation ，因为在compilation 阶段调用了Loader,完成了每个模块的转换操作。在compilation 阶段又会发生很多小事件        
| 事件名 | 解释 | 
| :------| :------ | 
| build-module | 使用对应的Loader 去转换一个模块 | 
| normal-module-loader | 在用Loader 转换完一个模块后，使用acorn 解析转换后的内容，输出对应的抽象语法树(AST ），以方便Webpack 在后面对代码进行分析 | 
| program | 从配置的入口模块开始，分析其AST ，当遇到requi町等导入其他模块的语句时，便将其 加入依赖的模块列表中，同时对新找出的依赖模块递归分析，最终弄清楚所有模块的依赖关系 | 
| seal | 所有模块及其依赖的模块都通过Loader 转换完成，根据依赖关系开始生成Chunk | 

**3.输出阶段**
输出阶段发生的事件及解释   

| 事件名 | 解释 | 
| :------| :------ | 
| should-emit | 所有需要输出的文件己经生成，询问插件有哪些文件需要输出， 有哪些不需要输出 | 
| emit | 确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出的内容 | 
| after-emit | 文件输出完毕 | 
| done | 成功完成一次完整的编译和输出流程 | 
| failed | 如果在编译和输出的流程中遇到异常，导致Webpack 退出， 就会直接跳转到本步骤，插件可以在本事件中获取具体的错误原因 | 

在输出阶段己经得到了各个模块经过转换后的结果和其依赖关系，并且将相关模块组合在一起形成一个个Chunk 。在输出阶段会根据Chunk 的类型，使用对应的模板生成最终要要输出的文件内容。    



P254




